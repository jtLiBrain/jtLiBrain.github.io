<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jtlibrain.github.io","root":"/","scheme":"Gemini","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="本篇介绍ShuffleWriter的原理。shuffle任务的运行，请参看此文章。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spark shuffle writer">
<meta property="og:url" content="https://jtlibrain.github.io/2020/08/05/Spark-shuffle-writer/index.html">
<meta property="og:site_name" content="jtLiBrain">
<meta property="og:description" content="本篇介绍ShuffleWriter的原理。shuffle任务的运行，请参看此文章。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jtlibrain.github.io/images/spark/BypassMergeSortShuffleWriter.svg">
<meta property="og:image" content="https://jtlibrain.github.io/images/spark/UnsafeShuffleWriter.svg">
<meta property="og:image" content="https://jtlibrain.github.io/images/spark/UnsafeShuffleWriter-details.svg">
<meta property="og:image" content="https://jtlibrain.github.io/images/spark/ShuffleInMemorySorter-packPointer.svg">
<meta property="og:image" content="https://jtlibrain.github.io/images/spark/SortShuffleWriter.svg">
<meta property="article:published_time" content="2020-08-05T08:37:46.000Z">
<meta property="article:modified_time" content="2020-08-31T10:40:36.485Z">
<meta property="article:author" content="JT Li">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jtlibrain.github.io/images/spark/BypassMergeSortShuffleWriter.svg">

<link rel="canonical" href="https://jtlibrain.github.io/2020/08/05/Spark-shuffle-writer/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Spark shuffle writer | jtLiBrain</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">jtLiBrain</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">任何伟大的事都不会一蹴而就，三分智慧，七分韧性</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#DiskBlockObjectWriter"><span class="nav-number">1.</span> <span class="nav-text">DiskBlockObjectWriter</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BypassMergeSortShuffleWriter%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">BypassMergeSortShuffleWriter原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UnsafeShuffleWriter%E5%8E%9F%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">UnsafeShuffleWriter原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TaskMemoryManager"><span class="nav-number">3.1.</span> <span class="nav-text">TaskMemoryManager</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UnsafeShuffleWriter"><span class="nav-number">3.2.</span> <span class="nav-text">UnsafeShuffleWriter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.1.</span> <span class="nav-text">写入数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.2.</span> <span class="nav-text">合并文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ShuffleExternalSorter"><span class="nav-number">3.3.</span> <span class="nav-text">ShuffleExternalSorter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5record%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.1.</span> <span class="nav-text">插入record数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%A2%E5%86%99"><span class="nav-number">3.3.2.</span> <span class="nav-text">溢写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ShuffleInMemorySorter"><span class="nav-number">3.4.</span> <span class="nav-text">ShuffleInMemorySorter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95%E6%8C%87%E9%92%88"><span class="nav-number">3.4.1.</span> <span class="nav-text">插入记录指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">3.4.2.</span> <span class="nav-text">排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SortShuffleWriter%E5%8E%9F%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">SortShuffleWriter原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SortShuffleWriter"><span class="nav-number">4.1.</span> <span class="nav-text">SortShuffleWriter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ExternalSorter"><span class="nav-number">4.2.</span> <span class="nav-text">ExternalSorter</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">JT Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:jtli.brain@hotmail.com" title="E-Mail → mailto:jtli.brain@hotmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jtlibrain.github.io/2020/08/05/Spark-shuffle-writer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="JT Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jtLiBrain">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spark shuffle writer
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-05 16:37:46" itemprop="dateCreated datePublished" datetime="2020-08-05T16:37:46+08:00">2020-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-31 18:40:36" itemprop="dateModified" datetime="2020-08-31T18:40:36+08:00">2020-08-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index"><span itemprop="name">spark</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本篇介绍ShuffleWriter的原理。shuffle任务的运行，请参看<a href="/2020/08/28/Spark-run-task-details/#ShuffleMapTask">此文章</a>。</p>
<a id="more"></a>

<h1 id="DiskBlockObjectWriter"><a href="#DiskBlockObjectWriter" class="headerlink" title="DiskBlockObjectWriter"></a>DiskBlockObjectWriter</h1><p>我们首先来看一下DiskBlockObjectWriter，接下来要介绍的三种ShuffleWriter都是用这个类，DiskBlockObjectWriter类将Java对象直接写入到磁盘上的文件，它封装并包装了文件流。</p>
<br/>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  fos = <span class="keyword">new</span> <span class="type">FileOutputStream</span>(file, <span class="literal">true</span>)</span><br><span class="line">  channel = fos.getChannel()</span><br><span class="line">  ts = <span class="keyword">new</span> <span class="type">TimeTrackingOutputStream</span>(writeMetrics, fos)</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ManualCloseBufferedOutputStream</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">BufferedOutputStream</span>(<span class="params">ts, bufferSize</span>) <span class="keyword">with</span> <span class="title">ManualCloseOutputStream</span></span></span><br><span class="line"><span class="class">  <span class="title">mcs</span> </span>= <span class="keyword">new</span> <span class="type">ManualCloseBufferedOutputStream</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <br/>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(): <span class="type">DiskBlockObjectWriter</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasBeenClosed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">&quot;Writer already closed. Cannot be reopened.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">    initialize()</span><br><span class="line">    initialized = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bs = serializerManager.wrapStream(blockId, mcs) <span class="comment">// 对文件流进行压缩和加密</span></span><br><span class="line">  objOut = serializerInstance.serializeStream(bs) <span class="comment">// 对文件流进行序列化</span></span><br><span class="line">  streamOpen = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="BypassMergeSortShuffleWriter原理"><a href="#BypassMergeSortShuffleWriter原理" class="headerlink" title="BypassMergeSortShuffleWriter原理"></a>BypassMergeSortShuffleWriter原理</h1><p>BypassMergeSortShuffleWriter不利用缓存，根据输入记录的key，将其直接写入到单独文件，每个文件对应一个reduce分区，最后将这些文件按照分区ID依序拼接起来形成最终的输出文件。</p>
<p>优点：由序列化写入的临时shuffle文件拼接最终文件的时候，不需要解序列化，直接按字节流copy数据。</p>
<p>缺点：这个ShuffleWriter在有大量reduce分区时，性能不高，因为它会为所有reduce分区同时打开序列化器和文件流。</p>
<p><img src="/images/spark/BypassMergeSortShuffleWriter.svg"></p>
  <br/>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public void write(<span class="type">Iterator</span>&lt;<span class="type">Product2</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;&gt; records) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">  assert (partitionWriters == <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (!records.hasNext()) &#123;</span><br><span class="line">    partitionLengths = <span class="keyword">new</span> long[numPartitions];</span><br><span class="line">    shuffleBlockResolver.writeIndexFileAndCommit(shuffleId, mapId, partitionLengths, <span class="literal">null</span>);</span><br><span class="line">    mapStatus = <span class="type">MapStatus</span>$.<span class="type">MODULE</span>$.apply(blockManager.shuffleServerId(), partitionLengths);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">SerializerInstance</span> serInstance = serializer.newInstance();</span><br><span class="line">  <span class="keyword">final</span> long openStartTime = <span class="type">System</span>.nanoTime();</span><br><span class="line">  partitionWriters = <span class="keyword">new</span> <span class="type">DiskBlockObjectWriter</span>[numPartitions];</span><br><span class="line">  partitionWriterSegments = <span class="keyword">new</span> <span class="type">FileSegment</span>[numPartitions];</span><br><span class="line">  <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; numPartitions; i++) &#123;</span><br><span class="line">    <span class="comment">// 为每个分区分别创建临时分区文件和shuffle block</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Tuple2</span>&lt;<span class="type">TempShuffleBlockId</span>, <span class="type">File</span>&gt; tempShuffleBlockIdPlusFile =</span><br><span class="line">      blockManager.diskBlockManager().createTempShuffleBlock();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> file = tempShuffleBlockIdPlusFile._2();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">BlockId</span> blockId = tempShuffleBlockIdPlusFile._1();</span><br><span class="line">    <span class="comment">// 每个分区创建一个写入器</span></span><br><span class="line">    partitionWriters[i] =</span><br><span class="line">      blockManager.getDiskWriter(blockId, file, serInstance, fileBufferSize, writeMetrics);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Creating the file to write to and creating a disk writer both involve interacting with</span></span><br><span class="line">  <span class="comment">// the disk, and can take a long time in aggregate when we open many files, so should be</span></span><br><span class="line">  <span class="comment">// included in the shuffle write time.</span></span><br><span class="line">  writeMetrics.incWriteTime(<span class="type">System</span>.nanoTime() - openStartTime);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (records.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Product2</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; record = records.next();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">K</span> key = record._1();</span><br><span class="line">    <span class="comment">// 根据record的key，将其写入相应的分区文件中</span></span><br><span class="line">    partitionWriters[partitioner.getPartition(key)].write(key, record._2());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入完成，调用commitAndGet()和close()</span></span><br><span class="line">  <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; numPartitions; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DiskBlockObjectWriter</span> writer = partitionWriters[i];</span><br><span class="line">    partitionWriterSegments[i] = writer.commitAndGet();</span><br><span class="line">    writer.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">File</span> output = shuffleBlockResolver.getDataFile(shuffleId, mapId);</span><br><span class="line">  <span class="type">File</span> tmp = <span class="type">Utils</span>.tempFileWith(output);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将临时文件拼接成一个最终的文件</span></span><br><span class="line">    partitionLengths = writePartitionedFile(tmp);</span><br><span class="line">    <span class="comment">// 写入索引文件</span></span><br><span class="line">    shuffleBlockResolver.writeIndexFileAndCommit(shuffleId, mapId, partitionLengths, tmp);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp.exists() &amp;&amp; !tmp.delete()) &#123;</span><br><span class="line">      logger.error(<span class="string">&quot;Error while deleting temp file &#123;&#125;&quot;</span>, tmp.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mapStatus = <span class="type">MapStatus</span>$.<span class="type">MODULE</span>$.apply(blockManager.shuffleServerId(), partitionLengths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <br/>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将分区文件拼接成一个汇总文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 返回一个数值数组，其中数值项代表每个分区数据的字节长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> long[] writePartitionedFile(<span class="type">File</span> outputFile) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">  <span class="comment">// Track location of the partition starts in the output file</span></span><br><span class="line">  <span class="keyword">final</span> long[] lengths = <span class="keyword">new</span> long[numPartitions];</span><br><span class="line">  <span class="keyword">if</span> (partitionWriters == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// We were passed an empty iterator</span></span><br><span class="line">    <span class="keyword">return</span> lengths;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">FileOutputStream</span> out = <span class="keyword">new</span> <span class="type">FileOutputStream</span>(outputFile, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">final</span> long writeStartTime = <span class="type">System</span>.nanoTime();</span><br><span class="line">  boolean threwException = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; numPartitions; i++) &#123; <span class="comment">// 按分区ID，将分区文件数据copy到最终的文件</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">File</span> file = partitionWriterSegments[i].file();</span><br><span class="line">      <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">FileInputStream</span> in = <span class="keyword">new</span> <span class="type">FileInputStream</span>(file);</span><br><span class="line">        boolean copyThrewException = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          lengths[i] = <span class="type">Utils</span>.copyStream(in, out, <span class="literal">false</span>, transferToEnabled);</span><br><span class="line">          copyThrewException = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="type">Closeables</span>.close(in, copyThrewException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!file.delete()) &#123;</span><br><span class="line">          logger.error(<span class="string">&quot;Unable to delete file for partition &#123;&#125;&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    threwException = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="type">Closeables</span>.close(out, threwException);</span><br><span class="line">    writeMetrics.incWriteTime(<span class="type">System</span>.nanoTime() - writeStartTime);</span><br><span class="line">  &#125;</span><br><span class="line">  partitionWriters = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> lengths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="UnsafeShuffleWriter原理"><a href="#UnsafeShuffleWriter原理" class="headerlink" title="UnsafeShuffleWriter原理"></a>UnsafeShuffleWriter原理</h1><p><img src="/images/spark/UnsafeShuffleWriter.svg"></p>
<p>该类底层使用了 sun.misc.Unsafe，顾名思义叫UnsafeShuffleWriter。</p>
<p>在内部，它将数据序列化后提交给ShuffleExternalSorter，ShuffleExternalSorter将数据写入到内存分页当中，并同时将该数据在内存对应的地址信息（内存分页编号+内存的offset）和相应的分区ID进行编码作为数据指针插入到内存排序的ShuffleInMemorySorter中。</p>
<p>当发生溢写时，通过ShuffleInMemorySorter基于对数据指针进行排序（只对数据指针的分区ID进行排序）从而达到对数据排序的效果，从而对当前数据分页中的数据按分区ID的顺序依次输出到临时文件中。</p>
<p>ShuffleExternalSorter会将最后的内存分页写入到磁盘文件，合并阶段是完全基于这些溢写文件进行的。合并时，针对是否支持快速合并的要求，执行快合并或慢合并。</p>
<p>下图描绘了UnsafeShuffleWriter的实现细节：</p>
<p><img src="/images/spark/UnsafeShuffleWriter-details.svg"></p>
<h2 id="TaskMemoryManager"><a href="#TaskMemoryManager" class="headerlink" title="TaskMemoryManager"></a>TaskMemoryManager</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分页表，每个MemoryBlock都有pageNumber属性，该属性值对应相应MemoryBlock在该分页表的索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MemoryBlock</span>[] pageTable = <span class="keyword">new</span> <span class="type">MemoryBlock</span>[<span class="type">PAGE_TABLE_SIZE</span>];</span><br></pre></td></tr></table></figure>

<h2 id="UnsafeShuffleWriter"><a href="#UnsafeShuffleWriter" class="headerlink" title="UnsafeShuffleWriter"></a>UnsafeShuffleWriter</h2><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入当前分区的数据</span></span><br><span class="line">public void write(scala.collection.<span class="type">Iterator</span>&lt;<span class="type">Product2</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;&gt; records) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">  <span class="comment">// Keep track of success so we know if we encountered an exception</span></span><br><span class="line">  <span class="comment">// We do this rather than a standard try/catch/re-throw to handle</span></span><br><span class="line">  <span class="comment">// generic throwables.</span></span><br><span class="line">  boolean success = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (records.hasNext()) &#123;</span><br><span class="line">      insertRecordIntoSorter(records.next());</span><br><span class="line">    &#125;</span><br><span class="line">    closeAndWriteOutput();</span><br><span class="line">    success = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<p>MyByteArrayOutputStream扩展自ByteArrayOutputStream，是一个内存字节流；SerializationStream包装了MyByteArrayOutputStream，将record序列化后结果存入底层的MyByteArrayOutputStream；ByteArrayOutputStream公布了getBuf() ，这样就可以获取到底层序列化后的字节数据了。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void insertRecordIntoSorter(<span class="type">Product2</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; record) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">  assert(sorter != <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">K</span> key = record._1();</span><br><span class="line">  <span class="keyword">final</span> int partitionId = partitioner.getPartition(key);</span><br><span class="line">  serBuffer.reset();</span><br><span class="line">  serOutputStream.writeKey(key, <span class="type">OBJECT_CLASS_TAG</span>);</span><br><span class="line">  serOutputStream.writeValue(record._2(), <span class="type">OBJECT_CLASS_TAG</span>);</span><br><span class="line">  serOutputStream.flush();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> int serializedRecordSize = serBuffer.size();</span><br><span class="line">  assert (serializedRecordSize &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  sorter.insertRecord(</span><br><span class="line">    serBuffer.getBuf(), <span class="type">Platform</span>.<span class="type">BYTE_ARRAY_OFFSET</span>, serializedRecordSize, partitionId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并文件"><a href="#合并文件" class="headerlink" title="合并文件"></a>合并文件</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void closeAndWriteOutput() <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">  assert(sorter != <span class="literal">null</span>);</span><br><span class="line">  updatePeakMemoryUsed();</span><br><span class="line">  serBuffer = <span class="literal">null</span>;</span><br><span class="line">  serOutputStream = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 将全部的内存分页写入到磁盘，并释放相应内存</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">SpillInfo</span>[] spills = sorter.closeAndGetSpills();</span><br><span class="line">  sorter = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">final</span> long[] partitionLengths;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">File</span> output = shuffleBlockResolver.getDataFile(shuffleId, mapId);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">File</span> tmp = <span class="type">Utils</span>.tempFileWith(output);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      partitionLengths = mergeSpills(spills, tmp);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">SpillInfo</span> spill : spills) &#123;</span><br><span class="line">        <span class="keyword">if</span> (spill.file.exists() &amp;&amp; ! spill.file.delete()) &#123;</span><br><span class="line">          logger.error(<span class="string">&quot;Error while deleting spill file &#123;&#125;&quot;</span>, spill.file.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shuffleBlockResolver.writeIndexFileAndCommit(shuffleId, mapId, partitionLengths, tmp);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp.exists() &amp;&amp; !tmp.delete()) &#123;</span><br><span class="line">      logger.error(<span class="string">&quot;Error while deleting temp file &#123;&#125;&quot;</span>, tmp.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mapStatus = <span class="type">MapStatus</span>$.<span class="type">MODULE</span>$.apply(blockManager.shuffleServerId(), partitionLengths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> long[] mergeSpills(<span class="type">SpillInfo</span>[] spills, <span class="type">File</span> outputFile) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> boolean compressionEnabled = sparkConf.getBoolean(<span class="string">&quot;spark.shuffle.compress&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">CompressionCodec</span> compressionCodec = <span class="type">CompressionCodec</span>$.<span class="type">MODULE</span>$.createCodec(sparkConf);</span><br><span class="line">  <span class="keyword">final</span> boolean fastMergeEnabled =</span><br><span class="line">    sparkConf.getBoolean(<span class="string">&quot;spark.shuffle.unsafe.fastMergeEnabled&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 非压缩或Snappy、LZF、LZ4、ZStd都支持快速合并</span></span><br><span class="line">  <span class="keyword">final</span> boolean fastMergeIsSupported = !compressionEnabled ||</span><br><span class="line">    <span class="type">CompressionCodec</span>$.<span class="type">MODULE</span>$.supportsConcatenationOfSerializedStreams(compressionCodec);</span><br><span class="line">  <span class="keyword">final</span> boolean encryptionEnabled = blockManager.serializerManager().encryptionEnabled();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (spills.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">FileOutputStream</span>(outputFile).close(); <span class="comment">// Create an empty file</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> long[partitioner.numPartitions()];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (spills.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// Here, we don&#x27;t need to perform any metrics updates because the bytes written to this</span></span><br><span class="line">      <span class="comment">// output file would have already been counted as shuffle bytes written.</span></span><br><span class="line">      <span class="type">Files</span>.move(spills[<span class="number">0</span>].file, outputFile);</span><br><span class="line">      <span class="keyword">return</span> spills[<span class="number">0</span>].partitionLengths;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> long[] partitionLengths;</span><br><span class="line">            </span><br><span class="line">      <span class="comment">// 快速合并的前提是：</span></span><br><span class="line">      <span class="comment">// 1. 不开启压缩；</span></span><br><span class="line">      <span class="comment">// 2. 如果开启了压缩，Snappy、LZF、LZ4、ZStd是可以进行在不解压缩情况下，执行数据拼接</span></span><br><span class="line">      <span class="keyword">if</span> (fastMergeEnabled &amp;&amp; fastMergeIsSupported) &#123;</span><br><span class="line">        <span class="keyword">if</span> (transferToEnabled &amp;&amp; !encryptionEnabled) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Using transferTo-based fast merge&quot;</span>);</span><br><span class="line">          <span class="comment">// 使用NIO进行快速合并</span></span><br><span class="line">          partitionLengths = mergeSpillsWithTransferTo(spills, outputFile);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Using fileStream-based fast merge&quot;</span>);</span><br><span class="line">          <span class="comment">// 使用java文件流进行合并，往往会比mergeSpillsWithTransferTo()要慢</span></span><br><span class="line">          partitionLengths = mergeSpillsWithFileStream(spills, outputFile, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Using slow merge&quot;</span>);</span><br><span class="line">        <span class="comment">// 解压缩溢写文件流，在对输出流进行压缩，性能很差</span></span><br><span class="line">        partitionLengths = mergeSpillsWithFileStream(spills, outputFile, compressionCodec);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      writeMetrics.decBytesWritten(spills[spills.length - <span class="number">1</span>].file.length());</span><br><span class="line">      writeMetrics.incBytesWritten(outputFile.length());</span><br><span class="line">      <span class="keyword">return</span> partitionLengths;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="type">IOException</span> e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (outputFile.exists() &amp;&amp; !outputFile.delete()) &#123;</span><br><span class="line">      logger.error(<span class="string">&quot;Unable to delete output file &#123;&#125;&quot;</span>, outputFile.getPath());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ShuffleExternalSorter"><a href="#ShuffleExternalSorter" class="headerlink" title="ShuffleExternalSorter"></a>ShuffleExternalSorter</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排序的内存分页，这些分页的内存已经被释放并且其内的数据已经被溢写到磁盘</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">LinkedList</span>&lt;<span class="type">MemoryBlock</span>&gt; allocatedPages = <span class="keyword">new</span> <span class="type">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次溢写由一个来表示</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">LinkedList</span>&lt;<span class="type">SpillInfo</span>&gt; spills = <span class="keyword">new</span> <span class="type">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前数据分页的排序器，每次溢写后，进行重置inMemSorter.reset()</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">private</span> <span class="type">ShuffleInMemorySorter</span> inMemSorter;</span><br><span class="line"><span class="comment">// 当前数据分页，每次溢写后，置空currentPage=null</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="keyword">private</span> <span class="type">MemoryBlock</span> currentPage = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 当前数据分页中的offset，每次溢写后，pageCursor=0</span></span><br><span class="line"><span class="keyword">private</span> long pageCursor = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>



<h3 id="插入record数据"><a href="#插入record数据" class="headerlink" title="插入record数据"></a>插入record数据</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void insertRecord(<span class="type">Object</span> recordBase, long recordOffset, int length, int partitionId)</span><br><span class="line">  <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for tests</span></span><br><span class="line">  assert(inMemSorter != <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (inMemSorter.numRecords() &gt;= numElementsForSpillThreshold) &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;Spilling data because number of spilledRecords crossed the threshold &quot;</span> +</span><br><span class="line">      numElementsForSpillThreshold);</span><br><span class="line">    spill();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  growPointerArrayIfNecessary();</span><br><span class="line">  <span class="keyword">final</span> int uaoSize = <span class="type">UnsafeAlignedOffset</span>.getUaoSize();</span><br><span class="line">  <span class="comment">// Need 4 or 8 bytes to store the record length.</span></span><br><span class="line">  <span class="keyword">final</span> int required = length + uaoSize;</span><br><span class="line">  acquireNewPageIfNecessary(required);</span><br><span class="line"></span><br><span class="line">  assert(currentPage != <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Object</span> base = currentPage.getBaseObject();</span><br><span class="line">  <span class="comment">// 对当前内存分页和pageCursor进行编码，作为当前写入数据的地址</span></span><br><span class="line">  <span class="comment">// 注意，该地址，高13位表示内存分页，低51为表示当前页的偏移量</span></span><br><span class="line">  <span class="keyword">final</span> long recordAddress = taskMemoryManager.encodePageNumberAndOffset(currentPage, pageCursor);</span><br><span class="line">  <span class="type">UnsafeAlignedOffset</span>.putSize(base, pageCursor, length);</span><br><span class="line">  pageCursor += uaoSize;</span><br><span class="line">  <span class="comment">// 1. 从序列化数据recordBase的recordOffset处，到base的pageCursor处，copy数据，长度为length，</span></span><br><span class="line">  <span class="comment">//    注意这里数据页中留出了uaoSize对齐的空间</span></span><br><span class="line">  <span class="type">Platform</span>.copyMemory(recordBase, recordOffset, base, pageCursor, length);</span><br><span class="line">  pageCursor += length;</span><br><span class="line">  <span class="comment">// 2. 向inMemSorter插入指针记录，用于排序</span></span><br><span class="line">  inMemSorter.insertRecord(recordAddress, partitionId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="溢写"><a href="#溢写" class="headerlink" title="溢写"></a>溢写</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sort and spill the current records in response to memory pressure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">public long spill(long size, <span class="type">MemoryConsumer</span> trigger) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (trigger != <span class="keyword">this</span> || inMemSorter == <span class="literal">null</span> || inMemSorter.numRecords() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>L;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  logger.info(<span class="string">&quot;Thread &#123;&#125; spilling sort data of &#123;&#125; to disk (&#123;&#125; &#123;&#125; so far)&quot;</span>,</span><br><span class="line">    <span class="type">Thread</span>.currentThread().getId(),</span><br><span class="line">    <span class="type">Utils</span>.bytesToString(getMemoryUsage()),</span><br><span class="line">    spills.size(),</span><br><span class="line">    spills.size() &gt; <span class="number">1</span> ? <span class="string">&quot; times&quot;</span> : <span class="string">&quot; time&quot;</span>);</span><br><span class="line"></span><br><span class="line">  writeSortedFile(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">final</span> long spillSize = freeMemory();</span><br><span class="line">  inMemSorter.reset();</span><br><span class="line">  <span class="comment">// Reset the in-memory sorter&#x27;s pointer array only after freeing up the memory pages holding the</span></span><br><span class="line">  <span class="comment">// records. Otherwise, if the task is over allocated memory, then without freeing the memory</span></span><br><span class="line">  <span class="comment">// pages, we might not be able to get memory for the pointer array.</span></span><br><span class="line">  taskContext.taskMetrics().incMemoryBytesSpilled(spillSize);</span><br><span class="line">  <span class="keyword">return</span> spillSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对内存中的记录进行排序，然后将排序后的记录写入到磁盘上的文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> void writeSortedFile(boolean isLastFile) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">ShuffleWriteMetrics</span> writeMetricsToUse;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isLastFile) &#123;</span><br><span class="line">    <span class="comment">// We&#x27;re writing the final non-spill file, so we _do_ want to count this as shuffle bytes.</span></span><br><span class="line">    writeMetricsToUse = writeMetrics;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We&#x27;re spilling, so bytes written should be counted towards spill rather than write.</span></span><br><span class="line">    <span class="comment">// Create a dummy WriteMetrics object to absorb these metrics, since we don&#x27;t want to count</span></span><br><span class="line">    <span class="comment">// them towards shuffle bytes written.</span></span><br><span class="line">    writeMetricsToUse = <span class="keyword">new</span> <span class="type">ShuffleWriteMetrics</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对当前数据分页对应的指针数组进行排序</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">ShuffleInMemorySorter</span>.<span class="type">ShuffleSorterIterator</span> sortedRecords =</span><br><span class="line">    inMemSorter.getSortedIterator();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 小数据量写入到DiskBlockObjectWriter性能是极其不高效的，这里使用字节数据充当缓存</span></span><br><span class="line">  <span class="keyword">final</span> byte[] writeBuffer = <span class="keyword">new</span> byte[diskWriteBufferSize];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Because this output will be read during shuffle, its compression codec must be controlled by</span></span><br><span class="line">  <span class="comment">// spark.shuffle.compress instead of spark.shuffle.spill.compress, so we need to use</span></span><br><span class="line">  <span class="comment">// createTempShuffleBlock here; see SPARK-3426 for more details.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Tuple2</span>&lt;<span class="type">TempShuffleBlockId</span>, <span class="type">File</span>&gt; spilledFileInfo =</span><br><span class="line">    blockManager.diskBlockManager().createTempShuffleBlock();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">File</span> file = spilledFileInfo._2();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">TempShuffleBlockId</span> blockId = spilledFileInfo._1();</span><br><span class="line">  <span class="keyword">final</span> <span class="type">SpillInfo</span> spillInfo = <span class="keyword">new</span> <span class="type">SpillInfo</span>(numPartitions, file, blockId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们需要一个serializer实例来构造DiskBlockObjectWriter对象，DiskBlockObjectWriter对象封装并包装了文件流，</span></span><br><span class="line">  <span class="comment">// 但UnsafeShuffleWriter实际上并没有使用这个serializer，因为下面写入文件时调用的是</span></span><br><span class="line">  <span class="comment">// DiskBlockObjectWriter.write(kvBytes: Array[Byte], offs: Int, len: Int)，</span></span><br><span class="line">  <span class="comment">// 这个方法实际直接将字节数据写入包装后的压缩流，并没有使用序列化流，</span></span><br><span class="line">  <span class="comment">// 因为数据分页中的数据已经是经过序列化后的数据了</span></span><br><span class="line">  <span class="comment">// 所以，这里传递了一个虚设的没有任何操作的serializer。</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">SerializerInstance</span> ser = <span class="type">DummySerializerInstance</span>.<span class="type">INSTANCE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">DiskBlockObjectWriter</span> writer =</span><br><span class="line">    blockManager.getDiskWriter(blockId, file, ser, fileBufferSizeBytes, writeMetricsToUse);</span><br><span class="line"></span><br><span class="line">  int currentPartition = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">final</span> int uaoSize = <span class="type">UnsafeAlignedOffset</span>.getUaoSize();</span><br><span class="line">  <span class="keyword">while</span> (sortedRecords.hasNext()) &#123;</span><br><span class="line">    sortedRecords.loadNext();</span><br><span class="line">    <span class="keyword">final</span> int partition = sortedRecords.packedRecordPointer.getPartitionId();</span><br><span class="line">    assert (partition &gt;= currentPartition);</span><br><span class="line">    <span class="keyword">if</span> (partition != currentPartition) &#123;</span><br><span class="line">      <span class="comment">// Switch to the new partition</span></span><br><span class="line">      <span class="keyword">if</span> (currentPartition != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">FileSegment</span> fileSegment = writer.commitAndGet(); <span class="comment">// 每个分区对应一个文件分片</span></span><br><span class="line">        spillInfo.partitionLengths[currentPartition] = fileSegment.length();</span><br><span class="line">      &#125;</span><br><span class="line">      currentPartition = partition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> long recordPointer = sortedRecords.packedRecordPointer.getRecordPointer();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> recordPage = taskMemoryManager.getPage(recordPointer);</span><br><span class="line">    <span class="keyword">final</span> long recordOffsetInPage = taskMemoryManager.getOffsetInPage(recordPointer);</span><br><span class="line">    int dataRemaining = <span class="type">UnsafeAlignedOffset</span>.getSize(recordPage, recordOffsetInPage);</span><br><span class="line">    long recordReadPosition = recordOffsetInPage + uaoSize; <span class="comment">// skip over record length</span></span><br><span class="line">    <span class="keyword">while</span> (dataRemaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> int toTransfer = <span class="type">Math</span>.min(diskWriteBufferSize, dataRemaining);</span><br><span class="line">      <span class="comment">// 将数据从数据分页中copy到数组缓存</span></span><br><span class="line">      <span class="type">Platform</span>.copyMemory(</span><br><span class="line">        recordPage, recordReadPosition, writeBuffer, <span class="type">Platform</span>.<span class="type">BYTE_ARRAY_OFFSET</span>, toTransfer);</span><br><span class="line">      <span class="comment">// 将数据组缓存中的数据写入</span></span><br><span class="line">      writer.write(writeBuffer, <span class="number">0</span>, toTransfer);</span><br><span class="line">      recordReadPosition += toTransfer;</span><br><span class="line">      dataRemaining -= toTransfer;</span><br><span class="line">    &#125;</span><br><span class="line">    writer.recordWritten();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">FileSegment</span> committedSegment = writer.commitAndGet();</span><br><span class="line">  writer.close();</span><br><span class="line">  <span class="comment">// If `writeSortedFile()` was called from `closeAndGetSpills()` and no records were inserted,</span></span><br><span class="line">  <span class="comment">// then the file might be empty. Note that it might be better to avoid calling</span></span><br><span class="line">  <span class="comment">// writeSortedFile() in that case.</span></span><br><span class="line">  <span class="keyword">if</span> (currentPartition != <span class="number">-1</span>) &#123;</span><br><span class="line">    spillInfo.partitionLengths[currentPartition] = committedSegment.length();</span><br><span class="line">    spills.add(spillInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isLastFile) &#123;  <span class="comment">// i.e. this is a spill file</span></span><br><span class="line">    <span class="comment">// The current semantics of `shuffleRecordsWritten` seem to be that it&#x27;s updated when records</span></span><br><span class="line">    <span class="comment">// are written to disk, not when they enter the shuffle sorting code. DiskBlockObjectWriter</span></span><br><span class="line">    <span class="comment">// relies on its `recordWritten()` method being called in order to trigger periodic updates to</span></span><br><span class="line">    <span class="comment">// `shuffleBytesWritten`. If we were to remove the `recordWritten()` call and increment that</span></span><br><span class="line">    <span class="comment">// counter at a higher-level, then the in-progress metrics for records written and bytes</span></span><br><span class="line">    <span class="comment">// written would get out of sync.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// When writing the last file, we pass `writeMetrics` directly to the DiskBlockObjectWriter;</span></span><br><span class="line">    <span class="comment">// in all other cases, we pass in a dummy write metrics to capture metrics, then copy those</span></span><br><span class="line">    <span class="comment">// metrics to the true write metrics here. The reason for performing this copying is so that</span></span><br><span class="line">    <span class="comment">// we can avoid reporting spilled bytes as shuffle write bytes.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Note that we intentionally ignore the value of `writeMetricsToUse.shuffleWriteTime()`.</span></span><br><span class="line">    <span class="comment">// Consistent with ExternalSorter, we do not count this IO towards shuffle write time.</span></span><br><span class="line">    <span class="comment">// This means that this IO time is not accounted for anywhere; SPARK-3577 will fix this.</span></span><br><span class="line">    writeMetrics.incRecordsWritten(writeMetricsToUse.recordsWritten());</span><br><span class="line">    taskContext.taskMetrics().incDiskBytesSpilled(writeMetricsToUse.bytesWritten());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ShuffleInMemorySorter"><a href="#ShuffleInMemorySorter" class="headerlink" title="ShuffleInMemorySorter"></a>ShuffleInMemorySorter</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指针数组，</span></span><br><span class="line"><span class="comment"> * 1. 其中指针为：记录指针+分区ID经过PackedRecordPointer压缩后的指针；</span></span><br><span class="line"><span class="comment"> * 2. 排序操作实际是在该数组上进行的，而不是直接对底层数据进行排序；</span></span><br><span class="line"><span class="comment"> * 3. 该数据中只有一部分用于存储指针，剩余空间用作排序时的缓存；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">LongArray</span> array;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指针数组中新纪录插入的位置，每插入一条新记录，该指针递增1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> int pos = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="插入记录指针"><a href="#插入记录指针" class="headerlink" title="插入记录指针"></a>插入记录指针</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void insertRecord(long recordPointer, int partitionId) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasSpaceForAnotherRecord()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">&quot;There is no space for new record&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  array.set(pos, <span class="type">PackedRecordPointer</span>.packPointer(recordPointer, partitionId));</span><br><span class="line">  pos++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PackedRecordPointer.packPointer()压缩后的指针结构为：</p>
<p><img src="/images/spark/ShuffleInMemorySorter-packPointer.svg"></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对记录指针数组进行排序，并返回相应迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="type">ShuffleSorterIterator</span> getSortedIterator() &#123;</span><br><span class="line">  int offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (useRadixSort) &#123;</span><br><span class="line">    offset = <span class="type">RadixSort</span>.sort(</span><br><span class="line">      array, pos,</span><br><span class="line">      <span class="type">PackedRecordPointer</span>.<span class="type">PARTITION_ID_START_BYTE_INDEX</span>,</span><br><span class="line">      <span class="type">PackedRecordPointer</span>.<span class="type">PARTITION_ID_END_BYTE_INDEX</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">MemoryBlock</span> unused = <span class="keyword">new</span> <span class="type">MemoryBlock</span>(</span><br><span class="line">      array.getBaseObject(),</span><br><span class="line">      array.getBaseOffset() + pos * <span class="number">8</span>L,</span><br><span class="line">      (array.size() - pos) * <span class="number">8</span>L);</span><br><span class="line">    <span class="type">LongArray</span> buffer = <span class="keyword">new</span> <span class="type">LongArray</span>(unused);</span><br><span class="line">    <span class="type">Sorter</span>&lt;<span class="type">PackedRecordPointer</span>, <span class="type">LongArray</span>&gt; sorter =</span><br><span class="line">      <span class="keyword">new</span> <span class="type">Sorter</span>&lt;&gt;(<span class="keyword">new</span> <span class="type">ShuffleSortDataFormat</span>(buffer));</span><br><span class="line"></span><br><span class="line">    sorter.sort(array, <span class="number">0</span>, pos, <span class="type">SORT_COMPARATOR</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ShuffleSorterIterator</span>(pos, array, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SortShuffleWriter原理"><a href="#SortShuffleWriter原理" class="headerlink" title="SortShuffleWriter原理"></a>SortShuffleWriter原理</h1><p><img src="/images/spark/SortShuffleWriter.svg"></p>
<h2 id="SortShuffleWriter"><a href="#SortShuffleWriter" class="headerlink" title="SortShuffleWriter"></a>SortShuffleWriter</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(records: <span class="type">Iterator</span>[<span class="type">Product2</span>[<span class="type">K</span>, <span class="type">V</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  sorter = <span class="keyword">if</span> (dep.mapSideCombine) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ExternalSorter</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">C</span>](</span><br><span class="line">      context, dep.aggregator, <span class="type">Some</span>(dep.partitioner), dep.keyOrdering, dep.serializer)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不需要map端合并，则aggregator和ordering都传None，</span></span><br><span class="line">    <span class="comment">// 因为不需要关心每个分区种key是否是排序的；</span></span><br><span class="line">    <span class="comment">// 如果运行的是sortByKey，那么key的排序在reduce端进行</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">ExternalSorter</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">V</span>](</span><br><span class="line">      context, aggregator = <span class="type">None</span>, <span class="type">Some</span>(dep.partitioner), ordering = <span class="type">None</span>, dep.serializer)</span><br><span class="line">  &#125;</span><br><span class="line">  sorter.insertAll(records)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t bother including the time to open the merged output file in the shuffle write time,</span></span><br><span class="line">  <span class="comment">// because it just opens a single file, so is typically too fast to measure accurately</span></span><br><span class="line">  <span class="comment">// (see SPARK-3570).</span></span><br><span class="line">  <span class="keyword">val</span> output = shuffleBlockResolver.getDataFile(dep.shuffleId, mapId)</span><br><span class="line">  <span class="keyword">val</span> tmp = <span class="type">Utils</span>.tempFileWith(output)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> blockId = <span class="type">ShuffleBlockId</span>(dep.shuffleId, mapId, <span class="type">IndexShuffleBlockResolver</span>.<span class="type">NOOP_REDUCE_ID</span>)</span><br><span class="line">    <span class="keyword">val</span> partitionLengths = sorter.writePartitionedFile(blockId, tmp)</span><br><span class="line">    <span class="comment">// 写入索引文件</span></span><br><span class="line">    shuffleBlockResolver.writeIndexFileAndCommit(dep.shuffleId, mapId, partitionLengths, tmp)</span><br><span class="line">    mapStatus = <span class="type">MapStatus</span>(blockManager.shuffleServerId, partitionLengths)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tmp.exists() &amp;&amp; !tmp.delete()) &#123;</span><br><span class="line">      logError(<span class="string">s&quot;Error while deleting temp file <span class="subst">$&#123;tmp.getAbsolutePath&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ExternalSorter"><a href="#ExternalSorter" class="headerlink" title="ExternalSorter"></a>ExternalSorter</h2><p>PartitionedAppendOnlyMap</p>
<p>PartitionedPairBuffer</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/05/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/14/Spark-rpc-details/" rel="next" title="Spark RPC原理">
      Spark RPC原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JT Li</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'c94aa78cf2eda71757bf',
      clientSecret: '01e1353b3f8eac54aafb1224c784b7af0305ce8c',
      repo        : 'jtLiBrain.github.io',
      owner       : 'jtLiBrain',
      admin       : ['jtLiBrain'],
      id          : '202a951add50dcccc153a086e151ad2b',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
